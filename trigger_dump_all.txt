Table: trade_details, Trigger: after_trade_detail_insert, Event: INSERT, Timing: AFTER
Statement:
BEGIN
    DECLARE v_trade_type VARCHAR(20);
    DECLARE v_before_qty DECIMAL(15,2) DEFAULT 0;
    DECLARE v_after_qty DECIMAL(15,2) DEFAULT 0;
    DECLARE v_trade_date DATE;
    DECLARE v_count INT DEFAULT 0;
    DECLARE v_company_id INT;
    DECLARE v_warehouse_id INT;
    DECLARE v_display_order INT DEFAULT 1;
    DECLARE v_unit_weight DECIMAL(18,2);
    DECLARE v_calc_weight DECIMAL(18,2);

    SELECT trade_type, trade_date, company_id, warehouse_id 
    INTO v_trade_type, v_trade_date, v_company_id, v_warehouse_id
    FROM trade_masters WHERE id = NEW.trade_master_id;

    -- 품목 단위 중량 조회 (자동 계산용)
    SELECT weight INTO v_unit_weight FROM products WHERE id = NEW.product_id;
    SET v_calc_weight = IFNULL(NEW.total_weight, IFNULL(v_unit_weight * ABS(NEW.quantity), 0));

    -- 기초 재고 조회
    SELECT COUNT(*) INTO v_count FROM inventory WHERE product_id = NEW.product_id;
    IF v_count > 0 THEN
        SELECT IFNULL(quantity, 0) INTO v_before_qty FROM inventory WHERE product_id = NEW.product_id;
    ELSE
        SET v_before_qty = 0;
    END IF;

    -- 1. 매입(PURCHASE) 처리
    IF v_trade_type = 'PURCHASE' THEN
        SELECT IFNULL(MAX(display_order), 0) + 1 INTO v_display_order FROM purchase_inventory;
        SET v_after_qty = v_before_qty + NEW.quantity;
        
        INSERT INTO inventory (product_id, quantity, weight, purchase_price)
        VALUES (NEW.product_id, NEW.quantity, v_calc_weight, NEW.unit_price)
        ON DUPLICATE KEY UPDATE
            quantity = quantity + NEW.quantity,
            weight = weight + v_calc_weight,
            purchase_price = NEW.unit_price;

        INSERT INTO purchase_inventory (
            trade_detail_id, product_id, company_id, warehouse_id, purchase_date,
            original_quantity, remaining_quantity, unit_price, total_weight, weight_unit,
            shipper_location, sender, status, display_order
        ) VALUES (
            NEW.id, NEW.product_id, v_company_id, IFNULL(v_warehouse_id, 1), v_trade_date,
            NEW.quantity, NEW.quantity, NEW.unit_price, v_calc_weight, NEW.weight_unit,
            IFNULL(NEW.shipper_location, ''), IFNULL(NEW.sender, ''), 'AVAILABLE', v_display_order
        );

    -- 2. 매출(SALE) 처리
    ELSEIF v_trade_type = 'SALE' THEN
        SET v_after_qty = v_before_qty - NEW.quantity;
        -- 재고 부족 체크
        IF v_after_qty < 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '재고가 부족하여 매출을 등록할 수 없습니다.';
        END IF;

        UPDATE inventory
        SET quantity = quantity - NEW.quantity,
            weight = weight - v_calc_weight
        WHERE product_id = NEW.product_id;

    -- 3. 생산(PRODUCTION) 처리
    ELSEIF v_trade_type = 'PRODUCTION' THEN
        SET v_after_qty = v_before_qty + NEW.quantity;
        IF v_after_qty < 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '생산에 필요한 원재료 재고가 부족합니다.';
        END IF;

        UPDATE inventory
        SET quantity = quantity + NEW.quantity,
            weight = weight + v_calc_weight
        WHERE product_id = NEW.product_id;
    END IF;

    -- 수불부 기록 (모든 유형 공통)
    IF v_trade_type IN ('PURCHASE', 'SALE', 'PRODUCTION') THEN
        INSERT INTO inventory_transactions
        (transaction_date, transaction_type, product_id, quantity, weight, unit_price,
         before_quantity, after_quantity, trade_detail_id, reference_number, created_by)
        VALUES
        (v_trade_date, 
         CASE WHEN NEW.quantity > 0 THEN 'IN' ELSE 'OUT' END, 
         NEW.product_id, ABS(NEW.quantity), ABS(v_calc_weight), NEW.unit_price,
         v_before_qty, v_after_qty, NEW.id,
         (SELECT trade_number FROM trade_masters WHERE id = NEW.trade_master_id), 'system');
    END IF;
END
---------------------------------------------------
Table: trade_details, Trigger: after_trade_detail_update, Event: UPDATE, Timing: AFTER
Statement:
BEGIN
    DECLARE v_trade_type VARCHAR(20);
    DECLARE v_trade_date DATE;
    DECLARE v_trade_no VARCHAR(50);
    DECLARE v_unit_weight_old DECIMAL(18,2);
    DECLARE v_unit_weight_new DECIMAL(18,2);
    DECLARE v_calc_weight_old DECIMAL(18,2);
    DECLARE v_calc_weight_new DECIMAL(18,2);
    DECLARE v_before_qty DECIMAL(15,2);
    DECLARE v_after_qty_mid DECIMAL(15,2);
    DECLARE v_after_qty_final DECIMAL(15,2);

    SELECT trade_type, trade_date, trade_number INTO v_trade_type, v_trade_date, v_trade_no 
    FROM trade_masters WHERE id = NEW.trade_master_id;

    -- 0. 중량 및 현재 재고 조회
    SELECT weight INTO v_unit_weight_old FROM products WHERE id = OLD.product_id;
    SELECT weight INTO v_unit_weight_new FROM products WHERE id = NEW.product_id;
    SELECT IFNULL(quantity, 0) INTO v_before_qty FROM inventory WHERE product_id = OLD.product_id;
    
    SET v_calc_weight_old = IFNULL(OLD.total_weight, IFNULL(v_unit_weight_old * ABS(OLD.quantity), 0));
    SET v_calc_weight_new = IFNULL(NEW.total_weight, IFNULL(v_unit_weight_new * ABS(NEW.quantity), 0));

    -- 1. 이전 상태 복원 (Reverse OLD)
    IF v_trade_type = 'PURCHASE' THEN
        SET v_after_qty_mid = v_before_qty - OLD.quantity;
        UPDATE inventory SET quantity = quantity - OLD.quantity, weight = weight - v_calc_weight_old WHERE product_id = OLD.product_id;
    ELSEIF v_trade_type = 'SALE' THEN
        SET v_after_qty_mid = v_before_qty + OLD.quantity;
        UPDATE inventory SET quantity = quantity + OLD.quantity, weight = weight + v_calc_weight_old WHERE product_id = OLD.product_id;
    ELSEIF v_trade_type = 'PRODUCTION' THEN
        SET v_after_qty_mid = v_before_qty - OLD.quantity;
        UPDATE inventory SET quantity = quantity - OLD.quantity, weight = weight - v_calc_weight_old WHERE product_id = OLD.product_id;
    END IF;

    -- 복원 이력 기록 (DEBUG용)
    INSERT INTO inventory_transactions
    (transaction_date, transaction_type, product_id, quantity, weight, unit_price,
     before_quantity, after_quantity, trade_detail_id, reference_number, created_by, notes)
    VALUES
    (v_trade_date, 'ADJUST', OLD.product_id, OLD.quantity, v_calc_weight_old, OLD.unit_price,
     v_before_qty, v_after_qty_mid, OLD.id, v_trade_no, 'system', 'UPDATE_REVERSE');

    -- 2. 새 상태 반영 (Apply NEW)
    -- 새로운 before_qty 조회 (동일 품목일수도 있고 다를 수도 있음)
    SELECT IFNULL(quantity, 0) INTO v_before_qty FROM inventory WHERE product_id = NEW.product_id;

    IF v_trade_type = 'PURCHASE' THEN
        SET v_after_qty_final = v_before_qty + NEW.quantity;
        UPDATE inventory SET quantity = quantity + NEW.quantity, weight = weight + v_calc_weight_new, purchase_price = NEW.unit_price WHERE product_id = NEW.product_id;
    ELSEIF v_trade_type = 'SALE' THEN
        SET v_after_qty_final = v_before_qty - NEW.quantity;
        UPDATE inventory SET quantity = quantity - NEW.quantity, weight = weight - v_calc_weight_new WHERE product_id = NEW.product_id;
    ELSEIF v_trade_type = 'PRODUCTION' THEN
        SET v_after_qty_final = v_before_qty + NEW.quantity;
        UPDATE inventory SET quantity = quantity + NEW.quantity, weight = weight + v_calc_weight_new WHERE product_id = NEW.product_id;
    END IF;

    -- 새 상태 이력 기록
    INSERT INTO inventory_transactions
    (transaction_date, transaction_type, product_id, quantity, weight, unit_price,
     before_quantity, after_quantity, trade_detail_id, reference_number, created_by, notes)
    VALUES
    (v_trade_date, 
     CASE WHEN NEW.quantity > 0 THEN 'IN' ELSE 'OUT' END, 
     NEW.product_id, ABS(NEW.quantity), ABS(v_calc_weight_new), NEW.unit_price,
     v_before_qty, v_after_qty_final, NEW.id, v_trade_no, 'system', 'UPDATE_APPLY');
END
---------------------------------------------------
Table: trade_details, Trigger: before_trade_detail_delete, Event: DELETE, Timing: BEFORE
Statement:
BEGIN
    DECLARE v_trade_type VARCHAR(20);
    DECLARE v_trade_date DATE;
    DECLARE v_trade_no VARCHAR(50);
    DECLARE v_matched_count INT DEFAULT 0;
    DECLARE v_prod_count INT DEFAULT 0;
    DECLARE v_unit_weight DECIMAL(18,2);
    DECLARE v_calc_weight DECIMAL(18,2);
    DECLARE v_before_qty DECIMAL(15,2);
    DECLARE v_after_qty DECIMAL(15,2);
    
    SELECT trade_type, trade_date, trade_number INTO v_trade_type, v_trade_date, v_trade_no
    FROM trade_masters WHERE id = OLD.trade_master_id;

    -- trade_type이 없으면 작업 중단 (Shield 작동 실패 상황)
    IF v_trade_type IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '전표 정보를 찾을 수 없어 삭제를 중단합니다.';
    END IF;

    SELECT weight INTO v_unit_weight FROM products WHERE id = OLD.product_id;
    SET v_calc_weight = IFNULL(OLD.total_weight, IFNULL(v_unit_weight * ABS(OLD.quantity), 0));
    SELECT IFNULL(quantity, 0) INTO v_before_qty FROM inventory WHERE product_id = OLD.product_id;

    -- 1. 매입(PURCHASE) 삭제 가드
    IF v_trade_type = 'PURCHASE' THEN
        -- 매출 매칭 확인
        SELECT COUNT(*) INTO v_matched_count FROM sale_purchase_matching spm
        JOIN purchase_inventory pi ON spm.purchase_inventory_id = pi.id
        WHERE pi.trade_detail_id = OLD.id;

        IF v_matched_count > 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '이미 매출과 매칭된 매입 품목은 삭제할 수 없습니다.';
        END IF;

        -- 생산(Split) 투입 확인
        SELECT COUNT(*) INTO v_prod_count FROM inventory_production_ingredients ipi
        JOIN purchase_inventory pi ON ipi.used_inventory_id = pi.id
        WHERE pi.trade_detail_id = OLD.id;

        IF v_prod_count > 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '이미 품목 생산(분할)에 사용된 매입 품목은 삭제할 수 없습니다.';
        END IF;

        SET v_after_qty = v_before_qty - OLD.quantity;
        UPDATE inventory SET quantity = quantity - OLD.quantity, weight = weight - v_calc_weight WHERE product_id = OLD.product_id;
        DELETE FROM purchase_inventory WHERE trade_detail_id = OLD.id;

    -- 2. 매출(SALE) 삭제
    ELSEIF v_trade_type = 'SALE' THEN
        SET v_after_qty = v_before_qty + OLD.quantity;
        UPDATE inventory SET quantity = quantity + OLD.quantity, weight = weight + v_calc_weight WHERE product_id = OLD.product_id;
        
        -- 매칭 복원 (remaining_quantity 증가)
        UPDATE purchase_inventory pi
        JOIN sale_purchase_matching spm ON pi.id = spm.purchase_inventory_id
        SET pi.remaining_quantity = pi.remaining_quantity + spm.matched_quantity,
            pi.status = 'AVAILABLE'
        WHERE spm.sale_detail_id = OLD.id;
        
        DELETE FROM sale_purchase_matching WHERE sale_detail_id = OLD.id;

    -- 3. 생산(PRODUCTION) 삭제 가드
    ELSEIF v_trade_type = 'PRODUCTION' THEN
        -- 만약 Output 품목(quantity > 0) 삭제라면, 그 Output이 판매되었는지 확인
        IF OLD.quantity > 0 THEN
            SELECT COUNT(*) INTO v_matched_count FROM sale_purchase_matching spm
            JOIN purchase_inventory pi ON spm.purchase_inventory_id = pi.id
            WHERE pi.trade_detail_id = OLD.id;

            IF v_matched_count > 0 THEN
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '생산된 품목이 이미 판매되어 작업을 취소할 수 없습니다.';
            END IF;

            DELETE FROM purchase_inventory WHERE trade_detail_id = OLD.id;
        END IF;

        -- 결과적으로 aggregate inventory는 원복
        SET v_after_qty = v_before_qty - OLD.quantity;
        UPDATE inventory SET quantity = quantity - OLD.quantity, weight = weight - v_calc_weight WHERE product_id = OLD.product_id;
    END IF;

    -- 삭제 이력 기록
    INSERT INTO inventory_transactions
    (transaction_date, transaction_type, product_id, quantity, weight, unit_price,
     before_quantity, after_quantity, trade_detail_id, reference_number, created_by, notes)
    VALUES
    (v_trade_date, 'ADJUST', OLD.product_id, OLD.quantity, v_calc_weight, OLD.unit_price,
     v_before_qty, v_after_qty, OLD.id, v_trade_no, 'system', 'DELETE_REVERSE');
END
---------------------------------------------------
Table: trade_masters, Trigger: before_trade_master_delete, Event: DELETE, Timing: BEFORE
Statement:
BEGIN 
                -- 하위 trade_details를 명시적으로 먼저 삭제하여 after_trade_detail_delete 트리거가 trade_masters 데이터를 볼 수 있게 함
                DELETE FROM trade_details WHERE trade_master_id = OLD.id; 
            END
---------------------------------------------------
